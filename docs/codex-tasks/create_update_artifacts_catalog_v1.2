## Codex Task — Create/Update `docs/artifacts_catalog.md` entries for one job (v1.2)

**TARGET_SCRIPT (edit only this line when reusing the task):**
`jobs/vendor_input_processing/preprocessIncomingBmecat/glue_script.py`

### Objective

Create or update **artifact entries in `docs/artifacts_catalog.md`** that correspond to **all inputs + outputs + config_files** of the job that owns `TARGET_SCRIPT`, strictly following:

* `docs/standards/artifacts_catalog_spec_v1.1.md`

The result must be **fit for automation**, meaning:

* stable artifact_ids (artifact type, not run-specific variables),
* minimal avoidable TBDs,
* no invented lineage/consumers.

### Allowed changes (hard constraint)

You may **only** create/update:

* `docs/artifacts_catalog.md`

Do **not** modify any other files.

---

## Derivations (must be automatic; do not ask the user)

From `TARGET_SCRIPT`, derive:

* `JOB_DIR` = directory containing `TARGET_SCRIPT`
* `JOB_ID` = last folder name of `JOB_DIR`
* `MANIFEST_PATH` = `${JOB_DIR}/job_manifest.yaml`
* `ARTIFACTS_CATALOG_PATH` = `docs/artifacts_catalog.md`
* `SPEC_PATH` = `docs/standards/artifacts_catalog_spec_v1.1.md`

If `MANIFEST_PATH` does not exist → **fail the task** (no fallback guessing from code).

---

## Source priority (must follow spec)

Populate each artifact entry using this priority:

1. Use `MANIFEST_PATH` first (inputs/outputs/config_files, formats, required, bucket + key_pattern).
2. Use business descriptions for `purpose` / meaning **only if present in repo** under `docs/business_descriptions/` and clearly matching `JOB_ID` and/or the artifact name.
3. Use code only for `content_contract` items that cannot be proven from (1) or (2).
4. Use `TBD` only if truly not provable.

No invented facts.

---

## What must be represented

For the current job (`JOB_ID`), create/update one artifacts catalog entry per artifact type, covering:

A) **Every `inputs[]` item** in the manifest
B) **Every `outputs[]` item** in the manifest
C) **Every `config_files[]` item** in the manifest

If multiple manifest entries refer to the same artifact type (same filename pattern), represent it once (do not duplicate).

---

## Artifact ID rules (stable; no runtime-variable leakage)

Each catalog entry MUST have a stable `artifact_id` in snake_case.

Construct `artifact_id` deterministically as:

`<job_id_snake_case>__<artifact_type_snake_case>`

Where:

* `job_id_snake_case` = snake_case of `JOB_ID`
* `artifact_type_snake_case` must be derived from the **file type name**, not from runtime variables.

### How to derive `<artifact_type_snake_case>`

Start with a “base name” derived from the manifest item:

1. If `key_pattern` ends with a filename:

   * take the last segment (filename)
2. Else if `key_pattern` is a pure parameter placeholder like `${bmecat_input_key}`:

   * use the parameter name (e.g., `bmecat_input_key`)
3. Else:

   * use the last path segment of `key_pattern`

Then normalize:

* Remove leading `${vendor_name}_` or `${vendor}_` prefixes if present in the filename.
* Remove other common variable tokens from the base name when they represent run-time context rather than artifact type:

  * remove `${vendor_name}` occurrences
  * remove timestamp/run-id substrings if present as placeholders
* Remove file extensions (`.json`, `.ndjson`, `.xml`, etc.)
* Convert remaining to `snake_case`.

**Forbidden:** putting `vendor_name` or `tbd` into `artifact_id`.

---

## Producer/consumer lineage rules (automation-safe)

### Producers

* For **outputs** produced by this job:

  * `producer_job_id: <JOB_ID>`
  * `producer_glue_job_name:`

    * use manifest `glue_job_name` if not `TBD`, else if manifest parameters include `JOB_NAME`, set `${JOB_NAME}`, else `TBD`.

* For **inputs** and **config_files** consumed by this job:

  * `producer_job_id: TBD`
  * `producer_glue_job_name: TBD`
    (Never attribute production of inputs/configs to the current job.)

### Consumers

* For **inputs** and **config_files**:

  * `consumers` MUST include the current job (`JOB_ID`) because it consumes them.
* For **outputs**:

  * determine additional consumers by scanning all other `jobs/**/job_manifest.yaml` files.
  * Add a job as a consumer ONLY if a downstream manifest contains an input whose `bucket` + `key_pattern` matches this artifact’s pattern (see matching rules below).
  * If no provable downstream consumers exist: `consumers: - TBD` (do not guess).

#### Matching rules for discovering downstream consumers

An output artifact matches a downstream input if any of these is true:

1. Exact match of `bucket` and `key_pattern`.
2. Filename match: downstream `key_pattern` ends with the same filename pattern as this artifact’s `file_name_pattern`.
3. Prefix+filename match: downstream `key_pattern` contains this artifact’s filename pattern as its last segment and shares a common prefix root.

If matching is ambiguous (multiple plausible artifacts), do not add consumers → leave `TBD`.

---

## Field population rules (must minimize avoidable TBDs)

For every entry, populate all fields per `artifacts_catalog_spec_v1.1.md`. Apply the following **general inference rules** to avoid unnecessary TBDs:

### file_name_pattern

* If `key_pattern` ends with a filename → use that filename (may include placeholders).
* If `key_pattern` is a parameter placeholder (e.g., `${bmecat_input_key}`) → set `file_name_pattern: ${bmecat_input_key}` (not `TBD`).
* Otherwise `TBD` only if no stable name can be proven.

### s3_location_pattern

* Must be `s3://${bucket}/${key_pattern}`.
* If multiple locations apply, use a bullet list (allowed by spec).

### format (strong inference)

* If manifest provides `format`, use it.
* If manifest `format` is `TBD` but `file_name_pattern` ends with:

  * `.json` → set `format: json`
  * `.ndjson` → set `format: ndjson`
  * `.xml` → set `format: xml`
* If none applies → `other` or `TBD` (only if truly unknown).

### purpose

* Prefer business description language if available.
* Else derive a minimal factual purpose from artifact naming and manifest role:

  * e.g., “Extracted vendor products from BMECAT.”
  * e.g., “Configuration for BMECAT preprocessing job outputs.”
    No speculation.

---

## content_contract rules (automation-grade but spec-compliant)

The catalog must remain “shape + meaning”, not a schema.

### top_level_type

* `format=xml` → `scalar`
* `format=ndjson` → treat conceptually as **array** → set `top_level_type: array`
* `format=json` → set `object|array|scalar` only if provable; else `TBD`

### primary_keying

Fill only if provable:

* Prefer business description statements (“keyed by article_id”, etc.).
* Else use code evidence if explicit (e.g., output is built as dict keyed by a field).
* Else `TBD`.

### required_sections

* Only list high-level sections if provable from code/business description.
* For config JSON: if code requires top-level `outputs` or specific named output blocks, list them at high-level granularity.
* Else `- TBD`.

### empty_behavior (make it deterministic where possible)

Populate using this priority:

1. If code explicitly writes `{}` → `empty_object`
2. If code explicitly writes `[]` → `empty_array`
3. For `format=ndjson`:

   * Default to `empty_array` (0 records → 0-line NDJSON) unless code clearly omits the file on success.
   * Set `notes` to: `Serialized as NDJSON (1 JSON object per line). Empty case represented as 0-line NDJSON.`
4. If output writing is clearly gated by config (i.e., may not be written even on success):

   * Set `empty_behavior: absent_file`
   * Add note: `May be absent if not enabled by configuration.`
5. If none provable → `TBD`

### notes

Never leave `notes: TBD` for NDJSON:

* Always state: `Serialized as NDJSON (1 JSON object per line).`
  Add any additional factual constraints if proven.

---

## stability and breaking_change_rules

* Do not invent governance policy.
* Set `stability` and `breaking_change_rules` to `TBD` unless an ADR/standard explicitly defines them.

---

## File creation / update rules

* If `docs/artifacts_catalog.md` does not exist:

  * Create it with:

    * title `# Artifacts Catalog`
    * one-line note “Follows docs/standards/artifacts_catalog_spec_v1.1.md”
    * then the entries.

* If it exists:

  * Update existing entries in place where `artifact_id` matches.
  * Insert missing entries for this job.
  * Do not delete unrelated entries.

---

## Quality gates (must be satisfied; must be stated in PR description)

Before finishing, confirm:

1. **Coverage:** Every manifest `inputs[]`, `outputs[]`, and `config_files[]` item is represented by exactly one catalog entry (or merged correctly if same artifact type).
2. **Stable IDs:** No `artifact_id` contains `vendor_name` or `tbd`.
3. **Lineage correctness:** No input/config entry uses `${JOB_NAME}` as producer; outputs may.
4. **Consumers evidence-based:** Outputs list only consumers proven by scanning other manifests; otherwise `TBD`. Inputs/configs list `JOB_ID` as consumer.
5. **Avoidable TBDs removed:** `format` is not `TBD` when it can be inferred from filename extension; NDJSON notes are never `TBD`.
6. **Spec compliance:** Each entry follows the exact heading/field order required by the spec.
7. **Scope:** Only `docs/artifacts_catalog.md` changed.

---

## Deliverable

Create a PR that updates only `docs/artifacts_catalog.md` per the above rules.

PR description must include:

* `TARGET_SCRIPT`, `JOB_ID`, `MANIFEST_PATH`
* created/updated `artifact_id`s (bullet list)
* explanation of any remaining `TBD`s and why they are not provable from repo evidence
